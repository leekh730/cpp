[2020.11.12]
Curve Bracket은 업무 단위로 나뉘어 진다.
업무의 size가 커지는 이유는 business의 size가 커지기 때문이다. 
C++에서 main{}(Curve Bracket)이라는 것이 꼭 있어야 실행이 가능하다!(타 언어들도 다 main function이 존재함), 전 세계 모든 프로그램들은 main이라는 function을 찾으며, 이것이 있어야 실행이 가능하다!

*Function의 형태
return_type(컴퓨터가 하는 답) function_name (parameter list)(우리가 컴퓨터에게 하는 물음) { }
물음이 하나 일 수도 있고 여러 개 일 수도 있기 때문에 list type의 형식을 같는다. Dict 등 여러 개의 변수를 다루는 집합도 가능하나 C++에는 list type만 존재!
컴퓨터가 주는 답은 int로 답을 준다.
원래는 여러 개를 물으면 여러 개의 답을 받을 수 있으나, 현재는 답을 하나만 받는 것으로 이해하자! (Python에서는 tuple type으로 여러 개의 답을 받을 수 있다.)

**예제)Funtion.cpp 찹조(한 파일 안에 function을 만들 때)
Compile은 위에서 아래로 진행 (Top-Down 방식)
function의 순서에 따라 진행되는지의 여부를 꼭 확인!

[2020.11.13]
영역참조 - 내가 어디까지 볼 수 있느냐, 전역변수, 지역변수와 상관있다.
예제)'NameSpaces.cpp'를 보자
1.namespace first_space{void func(){}}
2.namespace second_space{void func(){}}
위 1,2는 같은 이름의 함수를 사용하지만 함수를 다시 namespace의 Curver Bracket으로 감싸주었기 때문에
컴퓨터 입장에서는 위 두개를 다르게 인식한다. 즉, 컴퓨터가 볼 수 있는 영역은 가장 밖에 싸여진 {}이다.

확장자(.exe, .cpp 등)는 우리(인간)이 보기 편하게 나눠 놓은 것이지 컴퓨터에게는 의미가 없다.
컴퓨터는 우리가 쪼개놓은 것을 컴파일할 때 다시 모두 합쳐서 하나의 파일로 만들어 인식하게 된다.

[2020.11.17]
var and pointer var
int var; = 변수 선언
int *var; = 포인터 변수 선언

변수는 메모리 공간에 저장된 데이터 값을 들고 오는 것이고, 포인터 변수는 해당 메모리 공간의 주소를 알려줌
ex)
int *a; //포인터 변수 선언
cout << *a; //a의 데이터 값 호출(지금 현재 a에 아무런 값을 안넣었고 참조도 없기 때문에 임의의 쓰레기값이 호출됨)
cout << a; //a의 주소 값 호출

ex)
int *a;
int b = 10;
a = &b; //a가 b의 데이터 값을 reference(참조)
cout << *a << endl; //b의 데이터 값을 참조하기 때문에 10이 출력
cout << a << endl; //a의 주소 값을 출력 0x.....
